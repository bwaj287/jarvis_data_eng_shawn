package ca.jrvs.apps.trading.service;

import ca.jrvs.apps.trading.dao.AccountDao;
import ca.jrvs.apps.trading.dao.PositionDao;
import ca.jrvs.apps.trading.dao.SecurityOrderDao;
import ca.jrvs.apps.trading.dao.TraderDao;
import ca.jrvs.apps.trading.model.domain.Account;
import ca.jrvs.apps.trading.model.domain.Position;
import ca.jrvs.apps.trading.model.domain.Trader;
import ca.jrvs.apps.trading.model.view.TraderAccountView;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class TraderAccountService {
  private TraderDao traderDao;
  private AccountDao accountDao;
  private PositionDao positionDao;
  private SecurityOrderDao securityOrderDao;

  @Autowired
  public TraderAccountService(TraderDao traderDao, AccountDao accountDao, PositionDao positionDao, SecurityOrderDao securityOrderDao){
    this.traderDao = traderDao;
    this.accountDao = accountDao;
    this.positionDao = positionDao;
    this.securityOrderDao = securityOrderDao;
  }

  /**
   * Create a trader and initialize a new account with 0 amount.
   * -validate user input(all fileds must be non empty)
   * -create a trader
   * create an account
   * -create, setup, and return a new traderAccountView
   *
   * Assumption: to simplify the logic, each trader has only one account where traderId == accountId
   *
   * @param trader cannot be null. All fields cannot be null except for id(auto generated by db)
   * @return traderAccountView
   * @throws IllegalArgumentException is a trader has null fields or id is not null.
   */
  public TraderAccountView createTraderAndAccount(Trader trader){
    checkTrader(trader);
    trader.setId(traderDao.save(trader).getId());
    Account newAccount = new Account();
    newAccount.setAmount(0d);
    newAccount.setTrader_id(trader.getId());
    newAccount.setId(accountDao.save(newAccount).getId());
    TraderAccountView traderAccountView = new TraderAccountView();
    traderAccountView.setTrader(trader);
    traderAccountView.setAccount(newAccount);
    return traderAccountView;

  }

  private void checkTrader(Trader trader) {
    if(trader == null) throw  new IllegalArgumentException("trader is null");
    if(trader.getEmail()==null) throw new IllegalArgumentException("email is null");
    if(trader.getCountry()==null) throw new IllegalArgumentException("country is null");
    if(trader.getDob()==null) throw new IllegalArgumentException("date is null");
    if(trader.getFirst_name()==null) throw new IllegalArgumentException("firstName is null");
    if(trader.getLast_name()==null) throw new IllegalArgumentException("lastName is null");
  }

  /**
   * a trader can be deleted iff it has no open position and 0 cash balance
   * -validate trader id
   * -get trader account by traceId and check account balance
   * -get positions by accountId and check positions
   * -delete all securietyOrders, account, trader( in this order)
   *
   * @param traderId must not be null
   * @throws IllegalArgumentException if trader a trader is not null or not found or unable to delete
   */
  public void deleteTraderById(Integer traderId){
    checkTraderId(traderId);
    List<Account> accounts = accountDao.findByColumn("trader_id", traderId);
    checkAccountDeletable(accounts);
    Account account = accounts.get(0);
    List<Position> positions = positionDao.findByColumn("account_id", account.getId());
    checkPositionClosed(positions);
    securityOrderDao.deleteByColumn("account_id",account.getId());
    accountDao.deleteById(traderId);
    traderDao.deleteById(traderId);
  }

  private void checkPositionClosed(List<Position> positions) {
    if(!isPositionClosed(positions)){
      throw new IllegalArgumentException("positions are open");
    }
  }

  private void checkAccountDeletable(List<Account> accounts) {
    if (accounts.size() == 0) {
      throw new IllegalArgumentException("No account exists for this trader");
    }
    if (accounts.get(0).getAmount() != 0) {
      throw new IllegalArgumentException("account need to have o balance");
    }
  }

  private void checkTraderId(Integer traderId) {
      if(traderId == null|| !traderDao.existsById(traderId)){
        throw new IllegalArgumentException("no exist account");
      }
  }

  private boolean isPositionClosed(List<Position> positions){
    for(Position position:positions){
      if(position.getPosition()!=0) {
        return false;
      }
    }
    return true;
  }

  private void checkFund(double fund){
    if(fund<=0){
      throw new IllegalArgumentException("fund are less or equal to 0");
    }
  }

  /**
   * Deposit fund to an account by traderId
   *
   * @param traderId trader id
   * @param fund
   * @return update account
   * @throws IllegalArgumentException if traderId is null or not found, fund is less or equal to 0;
   */
  public Account deposit(Integer traderId, Double fund){
    checkTraderId(traderId);
    checkFund(fund);

    List<Account> accounts = accountDao.findByColumn("trader_id",traderId);
    if (accounts.size() == 0) {
      throw new IllegalArgumentException("No account exists for this trader");
    }
    Account account=accounts.get(0);

    return accountDao.updateAmountById(account,fund);
  }

  /**
   * withdraw fund from an account by traderId
   *
   * @param traderId
   * @param fund can not be 0
   * @return update account
   * @throws IllegalArgumentException if traderId is not found or null, fund is less or equal to 0 and insufficient balance
   */
  public Account withdraw(Integer traderId, Double fund){
    checkTraderId(traderId);
    checkFund(fund);

    List<Account>accounts=accountDao.findByColumn("trader_id",traderId);
    if (accounts.size() == 0) {
      throw new IllegalArgumentException("No account exists for this trader");
    }
    Account account=accounts.get(0);

    checkAccountInsufficientFund(account,fund);
    return accountDao.updateAmountById(account,fund * -1);
  }

  private void checkAccountInsufficientFund(Account account, Double fund) {
    if(account.getAmount()<fund){
      throw new IllegalArgumentException("insufficient account balance");
    }
  }
}
